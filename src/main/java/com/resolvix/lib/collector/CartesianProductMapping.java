package com.resolvix.lib.collector;

import com.google.common.collect.ImmutableSet;
import com.resolvix.lib.collector.impl.CartesianProductMappingAccumulator;
import com.resolvix.lib.collector.impl.CollectorImpl;

import java.util.List;
import java.util.function.*;
import java.util.stream.Collector;

public class CartesianProductMapping
{
    private CartesianProductMapping() { }

    /**
     * Returns a {@link Collector} which performs an efficient mapping of its
     * input elements, each comprising a repeating and a non-repeating
     * component as in the case of the elements of a cartesian product, to
     * output elements in which the repeating and non-repeating components
     * have been folded into a singular container object, output as a
     * {@link List}.
     *
     * @param classifier a function to derive the distinguishing classifier
     *  for a cartesian product element from the cartesian product provided
     *  as input to the {@code Collector}
     *
     * @param fullMapper a function that fully maps the cartesian product to
     *  the output object
     *
     * @param partialMapper a function that partially maps the cartesian
     *  product to an intermediate object capable of being "folded" into
     *  a fully mapped output object
     *
     * @param fold a method that, given a full mapped output object for a
     *  cartesian product element with given distinguishing classifier,
     *  "folds" a partially mapped intermediate object with the same
     *  distinguishing classifier into the fully mapped output object
     *
     * @param combine a method that, given two fully mapped output objects
     *  for a cartesian product element with a given distinguishing
     *  classifier, "combines" the two fully mapped cartesian product elements
     *  to form a single fully mapped output object
     *
     * @param <T> the type of the object constituting one of [potentially]
     *  many elements of a data set generated by the cartesian product of
     *  two originating data sets (the "cartiesian product")
     *
     * @param <K> the type of key distinguishing the elements of the data
     *  set constituting the cartesian product
     *
     * @param <U> the full mapping type of an element of the cartesian
     *  product to an object of the required output type
     *
     * @param <V> the partial mapping type of an element of the cartesian
     *  product capable of being "folded" into a fully mapped element of
     *  the cartesian product
     *
     * @return a {@code Collector} implementing the cartesian product mapping
     *  functionality.
     */
    public static <T, K, U, V> Collector<T, CartesianProductMappingAccumulator<T, K, U, V>, List<U>>
        cartesianProductMapping(
            Function<T, K> classifier,
            Function<T, U> fullMapper,
            Function<T, V> partialMapper,
            BiFunction<U, V, U> fold,
            BinaryOperator<U> combine)
    {
        return new CollectorImpl<>(
            () -> new CartesianProductMappingAccumulator<T, K, U, V>(
                classifier, fullMapper, partialMapper, fold, combine),
            CartesianProductMappingAccumulator::accept,
            CartesianProductMappingAccumulator::combine,
            CartesianProductMappingAccumulator::toList,
            ImmutableSet.of(Collector.Characteristics.UNORDERED)
        );
    }

    /**
     * Returns a {@link Collector} which performs an efficient mapping of its
     * input elements, each comprising a repeating and a non-repeating
     * component as in the case of the elements of a cartesian product, to
     * output elements in which the repeating and non-repeating components
     * have been folded into a singular container object, output as a
     * stream to a downstream {@link Collector} to facilitate further
     * transformation before output.
     *
     * @param classifier a function to derive the distinguishing classifier
     *  for a cartesian product element from the cartesian product provided
     *  as input to the {@code Collector}
     *
     * @param fullMapper a function that fully maps the cartesian product to
     *  the output object
     *
     * @param partialMapper a function that partially maps the cartesian
     *  product to an intermediate object capable of being "folded" into
     *  a fully mapped output object
     *
     * @param fold a method that, given a full mapped output object for a
     *  cartesian product element with given distinguishing classifier,
     *  "folds" a partially mapped intermediate object with the same
     *  distinguishing classifier into the fully mapped output object
     *
     * @param combine a method that, given two fully mapped output objects
     *  for a cartesian product element with a given distinguishing
     *  classifier, "combines" the two fully mapped cartesian product elements
     *  to form a single fully mapped output object
     *
     * @param downstream a downstream {@code Collector} performing additional
     *  post-collection processing on the fully mapped and reduced output
     *  objects
     *
     * @param <T> the type of the object constituting one of [potentially]
     *  many elements of a data set generated by the cartesian product of
     *  two originating data sets (the "cartiesian product")
     *
     * @param <K> the type of key distinguishing the elements of the data
     *  set constituting the cartesian product
     *
     * @param <U> the full mapping type of an element of the cartesian
     *  product to an object of the required output type
     *
     * @param <V> the partial mapping type of an element of the cartesian
     *  product capable of being "folded" into a fully mapped element of
     *  the cartesian product
     *
     * @param <R> the result type of the downstream reduction
     *
     * @return a {@code Collector} implementing the cartesian product mapping
     *  functionality.
     */
    public static <T, K, U, V, R> Collector<T, ?, R>
        cartesianProductMapping(
            Function<T, K> classifier,
            Function<T, U> fullMapper,
            Function<T, V> partialMapper,
            BiFunction<U, V, U> fold,
            BinaryOperator<U> combine,
            Collector<U, ?, R> downstream
    ) {
        return new CollectorImpl<>(
                () -> new CartesianProductMappingAccumulator<T, K, U, V>(
                        classifier, fullMapper, partialMapper, fold, combine),
                CartesianProductMappingAccumulator::accept,
                CartesianProductMappingAccumulator::combine,
                (CartesianProductMappingAccumulator<T, K, U, V> a) ->
                    a.stream().collect(downstream),
                ImmutableSet.of(Collector.Characteristics.UNORDERED)
        );
    }
}
