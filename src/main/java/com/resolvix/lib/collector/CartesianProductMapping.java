package com.resolvix.lib.collector;

import com.google.common.collect.ImmutableSet;
import com.resolvix.lib.collector.impl.CartesianProductMappingAccumulator;
import com.resolvix.lib.collector.impl.CollectorImpl;

import java.util.Set;
import java.util.function.*;
import java.util.stream.Collector;
import java.util.stream.Stream;

public class CartesianProductMapping
{

    /**
     *
     *
     * @param classifier a function to derive the distinguishing classifier
     *  for a cartesian product element from the cartesian product provided
     *  as input to the {@code Collector}
     *
     * @param fullMapper a function that fully maps the cartesian product to
     *  the output object
     *
     * @param partialMapper a function that partially maps the cartesian
     *  product to an intermediate object capable of being "folded" into
     *  a fully mapped output object
     *
     * @param fold a method that, given a full mapped output object for a
     *  cartesian product element with given distinguishing classifier,
     *  "folds" a partially mapped intermediate object with the same
     *  distinguishing classifier into the fully mapped output object
     *
     * @param combine a method that, given two fully mapped output objects
     *  for a cartesian product element with a given distinguishing
     *  classifier, "combines" the two fully mapped cartesian product elements
     *  to form a single fully mapped output object
     *
     * @param <T> the type of the object constituting one of [potentially]
     *  many elements of a data set generated by the cartesian product of
     *  two originating data sets (the "cartiesian product")
     *
     * @param <K> the type of the value distinguishing the elements of the
     *  data set constituting the cartesian product
     *
     * @param <U> the type of object constituting a full mapping of an
     *  element of the cartesian product to an object of the required
     *  output type
     *
     * @param <V> the type of object constituting a partial mapping of an
     *  element of the cartesian product to a partial object capable of
     *  being "folded" into a fully mapped element of the cartesian product.
     *
     * @param <R> the type of object to be output by the collector
     *
     * @return a {@code Collector} implementing the cartesian product mapping
     *  functionality.
     */
    public static <T, K, U, V, R extends Set<U>> Collector<T, CartesianProductMappingAccumulator<T, K, U, V>, R>
        cartesianProductMapping(
                Function<T, K> classifier,
                Function<T, U> fullMapper,
                Function<T, V> partialMapper,
                BiFunction<U, V, U> fold,
                BinaryOperator<U> combine,
                Supplier<R> setFactory
    ) {
        return new CollectorImpl<>(
            () -> new CartesianProductMappingAccumulator<T, K, U, V>(
                classifier, fullMapper, partialMapper, fold, combine),
            CartesianProductMappingAccumulator::accept,
            CartesianProductMappingAccumulator::combine,
            (CartesianProductMappingAccumulator<T, K, U, V> accumulator) -> {
                return toSet(accumulator, setFactory);
            },
            ImmutableSet.of(Collector.Characteristics.UNORDERED)
        );
    }

    private static <T, K, U, V, R extends Set<U>> R toSet(
            CartesianProductMappingAccumulator<T, K, U, V> accumulator,
            Supplier<R> setFactory) {
        R r = setFactory.get();
        accumulator.appendTo(r);
        return r;
    }


    public static <T, K, U, V, A, R> Collector<T, A, R>
        cartesianProductMapping(
                Function<T, K> classifier,
                Function<T, U> fullMapper,
                Function<T, V> partialMapper,
                BiFunction<U, V, U> fold,
                BinaryOperator<U> combine,
                Collector<U, A, R> downstream
    ) {
        return new CollectorImpl<T, CartesianProductMappingAccumulator<T, K, U, V>, R>(
                () -> new CartesianProductMappingAccumulator<T, K, U, V>(
                        classifier, fullMapper, partialMapper, fold, combine),
                CartesianProductMappingAccumulator::accept,
                CartesianProductMappingAccumulator::combine,
                (CartesianProductMappingAccumulator<T, K, U, V> accumulator) -> {
                    R r = accumulator.stream()
                        .collect(downstream);
                    return r;
                },
                ImmutableSet.of(Collector.Characteristics.UNORDERED)
        );
    }
}
